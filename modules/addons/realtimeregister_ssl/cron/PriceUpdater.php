<?php

namespace AddonModule\RealtimeRegisterSsl\cron;

use AddonModule\RealtimeRegisterSsl\controllers\addon\admin\ProductsCreator;
use AddonModule\RealtimeRegisterSsl\eHelpers\Whmcs;
use AddonModule\RealtimeRegisterSsl\eRepository\RealtimeRegisterSsl\KeyToIdMapping;
use AddonModule\RealtimeRegisterSsl\eRepository\RealtimeRegisterSsl\Products;
use AddonModule\RealtimeRegisterSsl\eRepository\RealtimeRegisterSsl\ProductsPrices;
use AddonModule\RealtimeRegisterSsl\eServices\provisioning\ConfigOptions as C;
use AddonModule\RealtimeRegisterSsl\models\productConfiguration\Repository;
use Illuminate\Database\Capsule\Manager as Capsule;

class PriceUpdater extends BaseTask
{
    protected $skipDailyCron = false;
    protected $defaultPriority = 4200;
    protected $defaultName = "SSL price updater";

    public function __invoke()
    {
        if ($this->enabledTask('cron_price_updater')) {
            logActivity("Realtime Register SSL: Price updater started");

            Whmcs::savelogActivityRealtimeRegisterSsl("Realtime Register SSL WHMCS: Products Price Updater started.");

            try {
                // get all products prices
                $apiProductsPrices = ProductsPrices::getInstance();

                foreach ($apiProductsPrices->getAllProductsPrices() as $productPrice) {
                    $productPrice->saveToDatabase();
                }

                $productModel = new Repository();
                // get RealtimeRegisterSsl all products
                $products = $productModel->getModuleProducts();
                $apiProducts = Products::getInstance();

                foreach ($products as $product) {
                    // if auto price not enabled skip product
                    if (!$product->{C::PRICE_AUTO_DOWNLOAD}) {
                        continue;
                    }
                    // load saved api price
                    $apiProduct = $apiProducts->getProduct(KeyToIdMapping::getIdByKey($product->{C::API_PRODUCT_ID}));
                    $apiPrice = $productPrice->loadSavedPriceData(KeyToIdMapping::getIdByKey($product->{C::API_PRODUCT_ID}));

                    //generate new price
                    $this->generateNewPricesBasedOnAPI($apiPrice, $apiProduct, $product->id);
                }
            } catch (\Exception $e) {
                Whmcs::savelogActivityRealtimeRegisterSsl(
                    "Realtime Register SSL WHMCS Products Price Updater Error: " . $e->getMessage()
                );
            }
            Whmcs::savelogActivityRealtimeRegisterSsl("Realtime Register SSL WHMCS: Products Price Updater completed.");
        }
    }

    private function generateNewPricesBasedOnAPI($apiPrices, $apiProduct, $productId)
    {
        $optionGroupResult = Capsule::table('tblproductconfiggroups')
            ->select('id')
            ->where('name', '=', 'RealtimeRegisterSSL - ' . ProductsCreator::displayName($apiProduct))
            ->where('description', '=', 'Auto generated by module - RealtimeRegisterSSL #' . $productId)
            ->first();
        $periods = $apiProduct->getPeriods();

        $commission = (new \AddonModule\RealtimeRegisterSsl\models\whmcs\product\Product($productId))
            ->configuration()
            ->getConfigOptions()[C::COMMISSION];

        $multiplier = $commission === '' ? 1 : 1 + $commission;
        $currentPrices = Capsule::table('tblpricing')
            ->where('relid', '=', $productId)
            ->where('type', '=', 'product')
            ->get();

        foreach ($periods as $period) {
            $newPrice = array_filter($apiPrices, function ($price) use ($period) {
                return $price->period == $period && $price->action === 'REQUEST';
            });

            self::generateNewPrice(array_pop($newPrice), $currentPrices, $multiplier, $period);
        }

        if ($optionGroupResult == null) {
            return;
        }

        $configOptions = Capsule::table('tblproductconfigoptions')
            ->select()
            ->where('gid', '=', $optionGroupResult->id)
            ->get();

        foreach ($configOptions as $configOption) {
            $configOptionSubs = Capsule::table('tblproductconfigoptionssub')
                ->select()
                ->where('configid', '=', $configOption->id)
                ->orderBy('sortorder')
                ->get();
            $currentPrices = Capsule::table('tblpricing')
                ->where('relid', '=', $configOptionSub->id)
                ->where('type', '=', 'configoptions')
                ->get();
            if (str_contains($configOption->optionname, ConfigOptions::OPTION_SANS_COUNT)) {
                $configOptionSub = $configOptionSubs[0];

                foreach ($periods as $period) {
                    $newPrice = array_filter($apiPrices, function ($price) use ($period) {
                        return $price->period == $period && $price->action === 'EXTRA_DOMAIN';
                    });
                    self::generateNewPrice(array_pop($newPrice), $currentPrices, $multiplier, $period);
                }
            } elseif (str_contains($configOption->optionname, ConfigOptions::OPTION_SANS_WILDCARD_COUNT)) {
                $configOptionSub = $configOptionSubs[0];

                foreach ($periods as $period) {
                    $newPrice = array_filter($apiPrices, function ($price) use ($period) {
                        return $price->period == $period && $price->action === 'EXTRA_WILDCARD';
                    });
                    self::generateNewPrice(array_pop($newPrice), $currentPrices, $multiplier, $period);
                }
            }
        }
    }

    private static function generateNewPrice($apiPrice, $currentPrices, $multiplier, $period)
    {
        switch ($period) {
            case 12:
                $periodString = 'annually';
                break;
            case 24:
                $periodString = 'biennially';
                break;
            case 36:;
                $periodString = 'triennially';
                break;
            default:
                return;
        }

        $productModel = new Repository();
        $currencies = $productModel->getAllCurrencies();
        $defaultCurrency = $currencies->filter(fn($currency) => $currency->default === 1)->first();

        if ($apiPrice->currency !== $defaultCurrency->code) {
            $currency = $currencies->filter(function ($currency) use ($apiPrice) {
                return $apiPrice->currency === $currency->code;
            })->first();
            if ($currency === null) {
                return;
            }
            $newPrice = $apiPrice->price / $currency->rate / 100;
        } else {
            $newPrice = $apiPrice->price / 100;
        }

        foreach ($currencies->toArray() as $currency) {
            $currentPrice = $currentPrices->filter(function ($price) use ($currency) {
                return $price->currency === $currency->id;
            })->first();

            Capsule::table("tblpricing")->where('id', '=', $currentPrice->id)
                ->update([$periodString => $newPrice * $currency->rate * $multiplier]);

            if ($periodString === 'annually' && floatval($currentPrice->monthly) > 0.00 ) {
                Capsule::table("tblpricing")->where('id', '=', $currentPrice->id)
                    ->update(['monthly' => $newPrice * $currency->rate * $multiplier]);
            }
        }
    }
}
