<?php
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

namespace AddonModule\RealtimeRegisterSsl\eHelpers;

use AddonModule\RealtimeRegisterSsl\addonLibs\MySQL\Query;
use AddonModule\RealtimeRegisterSsl\eServices\provisioning\ConfigOptions;
use AddonModule\RealtimeRegisterSsl\models\whmcs\clients\Client;
use AddonModule\RealtimeRegisterSsl\models\whmcs\invoices\RepositoryItem;
use AddonModule\RealtimeRegisterSsl\models\whmcs\pricing\BillingCycle;
use AddonModule\RealtimeRegisterSsl\models\whmcs\service\configOptions\Repository as ConfigOptionsRepo;
use AddonModule\RealtimeRegisterSsl\models\whmcs\service\Service;
use DateInterval;
use DateTime;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Database\Schema\Blueprint;
use WHMCS\Module\Server;
use WHMCS\Product\Product;

/**
 * Description of Invoice
 *
 */
class Invoice
{
    protected static $adminUserName = null;

    public const INVOICE_INFOS_TABLE_NAME = 'REALTIMEREGISTERSSL_invoices_info';
    public const INVOICE_PENDINGPAYMENT_TABLE_NAME = 'REALTIMEREGISTERSSL_invoices_pendingpayment';

    public static function createInfosTable()
    {
        if (!Capsule::schema()->hasTable(self::INVOICE_INFOS_TABLE_NAME)) {
            Capsule::schema()->create(self::INVOICE_INFOS_TABLE_NAME, function (Blueprint $table) {
                $table->increments('id');
                $table->integer('user_id')->unsigned();
                $table->integer('invoice_id')->unsigned();
                $table->integer('service_id')->unsigned()->index();
                $table->integer('product_id')->unsigned();
                $table->integer('order_id')->unsigned();
                $table->integer('new_service_id')->unsigned();
                $table->string('status');
                $table->timestamps();
                $table->index(['new_service_id', 'order_id'], 'rtrsiinsioii'); // autogenerated name was too long
                $table->index(['invoice_id', 'order_id']);
            });
        }
    }

    public static function createPendingPaymentInvoice()
    {
        if (!Capsule::schema()->hasTable(self::INVOICE_PENDINGPAYMENT_TABLE_NAME)) {
            Capsule::schema()->create(self::INVOICE_PENDINGPAYMENT_TABLE_NAME, function (Blueprint $table) {
                $table->increments('id');
                $table->integer('user_id')->unsigned();
                $table->integer('invoice_id')->unsigned();
                $table->timestamps();
            });
        }
    }

    public static function updateInfosTable(string $prefix = ''): void
    {
        if ($prefix && Capsule::schema()->hasTable($prefix . self::INVOICE_INFOS_TABLE_NAME)) {
            Capsule::schema()->rename($prefix . self::INVOICE_INFOS_TABLE_NAME,
                self::INVOICE_INFOS_TABLE_NAME);
        }
    }

    public static function updatePendingPaymentTable(string $prefix = ''): void
    {
        if ($prefix && Capsule::schema()->hasTable($prefix . self::INVOICE_PENDINGPAYMENT_TABLE_NAME)) {
            Capsule::schema()->rename($prefix . self::INVOICE_PENDINGPAYMENT_TABLE_NAME,
                self::INVOICE_PENDINGPAYMENT_TABLE_NAME);
        }
    }

    public function checkInvoiceAlreadyCreated($serviceIDs)
    {
        $services = Query::select(
            ['service_id', 'id', 'invoice_id'], self::INVOICE_INFOS_TABLE_NAME, ['service_id' => $serviceIDs]
        )->fetchAll();

        $result = [];
        foreach ($services as $srvinfo) {
            $invoice = Capsule::table('tblinvoices')
                ->where('id', $srvinfo['invoice_id'])->where('status', 'Paid')->first();
            if (!isset($invoice->id)) {
                $result[$srvinfo['service_id']] = $srvinfo;
            }
        }

        return $result;
    }

    public function getInvoiceCreatedInfo($invoiceId, $orderIdNull = true)
    {
        $wherePart = ' WHERE invoice_id = ' . $invoiceId;

        if ($orderIdNull) {
            $wherePart .= ' AND order_id = 0 ';
        }
        return Query::query('SELECT * FROM ' . self::INVOICE_INFOS_TABLE_NAME . $wherePart)->fetch();
    }

    protected static function getNewInvoiceCreatedInfo($newServiceId, $orderId = null)
    {
        $wherePart = ' WHERE new_service_id = ' . $newServiceId;

        if ($orderId != null) {
            $wherePart .= ' AND order_id = ' . $orderId;
        }
        return Query::query('SELECT * FROM ' . self::INVOICE_INFOS_TABLE_NAME . $wherePart)->fetch();
    }

    public static function getLatestCreatedInvoiceInfo($serviceId)
    {
        $wherePart = ' WHERE service_id = ' . $serviceId;

        return Query::query(
            'SELECT invoice_id FROM ' . self::INVOICE_INFOS_TABLE_NAME . $wherePart . ' ORDER BY id DESC LIMIT 1'
        )->fetch();
    }

    protected function getNextDueDate($nextduedate, $dateFormat = 'Y-m-d', $timeShift = 'P12M')
    {
        $datetime = new DateTime($nextduedate);

        $datetime->add(new DateInterval($timeShift)); //plus 1 year by default;
        $datetime->sub(new DateInterval('P1D')); //plus 1 year;

        return $datetime->format($dateFormat);
    }

    protected function getClientCurrencyID($id)
    {
        $clientRepo = new Client($id);
        return $clientRepo->getCurrencyId();
    }

    protected function getProductPricing($id)
    {
        $productRepo = new \AddonModule\RealtimeRegisterSsl\models\productConfiguration\Repository();
        return $productRepo->getProductPricing($id);
    }

    protected function getProperServiceBillingCycleBasedOnProductPricing($service)
    {
        //get client currency
        $clientCurrencyID = $this->getClientCurrencyID($service->userid);
        //get product pricing
        $productPricing = $this->getProductPricing($service->packageid);
        foreach ($productPricing as $pricing) {
            //check if pricing currency is clients currency and if service pricing period is setted
            if ($pricing->currency == $clientCurrencyID && $pricing->{strtolower($service->billingcycle)} != '-1.00') {
                return [
                    'key' => $service->billingcycle,
                    'price' => $pricing->{strtolower($service->billingcycle)}
                ];
            }
        }
        $highestAvailablePeriod = $highestAvailablePeriodPrice = 0;
        foreach ($productPricing as $pricing) {
            if ($pricing->currency == $clientCurrencyID) {
                foreach ($pricing as $key => $priceFieldValue) {
                    if (key_exists($key, BillingCycle::PERIODS) && $priceFieldValue != '-1.00') {
                        $period = BillingCycle::convertStringToPeriod($key);

                        if ($highestAvailablePeriod < $period) {
                            $highestAvailablePeriod = $period;
                            $highestAvailablePeriodPrice = $priceFieldValue;
                        }
                    }
                }
            }
        }

        // return highest available
        return [
            'key' => BillingCycle::convertPeriodToName($highestAvailablePeriod),
            'price' => $highestAvailablePeriodPrice
        ];
    }

    public function createInvoice($service, $product, $returnInvoiceID = false)
    {
        $apiConfigRepo = new \AddonModule\RealtimeRegisterSsl\models\apiConfiguration\Repository();
        $input = (array)$apiConfigRepo->get();

        $dateFormat = 'Y-m-d';

        $dateInvoice = date($dateFormat);
        //get discount
        $discount = Discount::getDiscountValue(
            ['pid' => $service->packageid, 'client' => $service->userid]
        );
        $multiplier = ((100 - $discount) / 100);

        $configOptions = $this->getConfigOptions($service);
        $clientCurrencyID = $this->getClientCurrencyID($service->userid);
        $billingCycle = $service->billingcycle;
        $pricing = get_query_val(
            "tblpricing",
            $billingCycle,
            [
                "type" => "product",
                "currency" => $clientCurrencyID,
                "relid" => $product->id
            ]
        );

        if ($pricing == "-1.00") {
            throw new \Exception("Pricing not available for period");
        }

        if ($billingCycle == 'One Time') {
            //get product pricing
            $invoiceItemDescription = $product->name . ($service->domain ? ' - ' . $service->domain : '')
                . ' - Renewal';
        } else {
            $timeShift = 'P' . BillingCycle::convertStringToPeriod($billingCycle) . 'M';
            $startDate = $service->nextduedate;
            $endDate = $this->getNextDueDate($service->nextduedate, $dateFormat, $timeShift);
            $invoiceItemDescription = $product->name . ($service->domain ? ' - ' . $service->domain : '')
                . ' (' . $startDate . ' - ' . $endDate . ') - Renewal';
        }

        //modify item amount based on client discount
        $invoiceData = [
            'userid' => $service->userid,
            'sendinvoice' => true,
            'date' => $dateInvoice,
            'duedate' => $dateInvoice,
            'itemdescription1' => $invoiceItemDescription,
            'itemamount1' => (float)$pricing * ((100 - $discount) / 100),
            'itemtaxed1' => $product->tax
        ];

        $boughtSans = empty($configOptions['single'])
            ? 0
            : $configOptions['single']['boughtSans'];


        $invoiceItemNum = 2;
        if ($boughtSans > 0) {
            $qtyprice = get_query_val(
                "tblpricing",
                $billingCycle,
                [
                    "type" => "configoptions",
                    "currency" => $clientCurrencyID,
                    "relid" => $configOptions['single']['configOptionID']
                ]
            );
            if ($qtyprice == "-1.00") {
                throw new \Exception("Pricing not available for period");
            }
            $optionname = formatCurrency($qtyprice);
            $invoiceData['itemdescription2'] = $configOptions['single']['friendlyName'] . ': ' . $boughtSans . ' x ' . $optionname;
            $invoiceData['itemamount2'] = $qtyprice * $boughtSans * $multiplier;
            $invoiceData['itemtaxed2'] = $product->tax;
            $invoiceItemNum++;
        }

        $boughtSansWildcard = empty($configOptions['wildcard'])
            ? 0
            : $configOptions['wildcard']['boughtSans'];

        if ($boughtSansWildcard > 0) {
            $qtyprice = get_query_val(
                "tblpricing",
                $billingCycle,
                ["type" => "configoptions",
                    "currency" => $clientCurrencyID,
                    "relid" => $configOptions['wildcard']['configOptionID']
                ]
            );
            if ($qtyprice == "-1.00") {
                throw new \Exception("Pricing not available for period");
            }
            $optionname = formatCurrency($qtyprice);
            $invoiceData['itemdescription' . $invoiceItemNum] = $configOptions['wildcard']['friendlyName']
                . ': ' . $configOptions['wildcard']['boughtSans']
                . ' x ' . $optionname;
            $invoiceData['itemamount' . $invoiceItemNum] = $qtyprice * $configOptions['wildcard']['boughtSans'] * $multiplier;
            $invoiceData['itemtaxed' . $invoiceItemNum] = $product->tax;
        }

        $adminUserName = Admin::getAdminUserName();


        $results = localAPI('CreateInvoice', $invoiceData, $adminUserName);

        $invoiceId = $results['invoiceid'];

        $this->saveInvoiceInfo($service->userid, $invoiceId, $service->id, $product->id);

        Capsule::table('tblinvoiceitems')
            ->where('invoiceid', '=', $invoiceId)
            ->update(['type' => 'Hosting']);

        /*
         * add relid to invoiceitem entry in the tblinvoiceitems table -> WHMCS does not fill this column
         * via local API CreateInvoice command
         */
        Capsule::table('tblinvoiceitems')
            ->where('invoiceid', '=', $invoiceId)
            ->update(['relid' => $service->id]);

        if ($boughtSans > 0) {
            Capsule::table('tblinvoiceitems')
                ->where('description', 'like', '%' . $configOptions['single']['friendlyName'] . '%')
                ->where('invoiceid', '=', $invoiceId)
                ->update(['relid' => $service->id, 'type' => '']);
        }
        if ($boughtSansWildcard > 0) {
            Capsule::table('tblinvoiceitems')
                ->where('description', 'like', '%' . $configOptions['wildcard']['friendlyName'] . '%')
                ->where('invoiceid', '=', $invoiceId)
                ->update(['relid' => $service->id, 'type' => '']);
        }

        if ($returnInvoiceID) {
            return $invoiceId;
        }

        return $results['result'] == 'success';
    }

    private function getConfigOptions($service): array
    {
        $configoptionsResults = [];
        $product = Product::where('id', $service->packageid)->first();
        $isSanEnabled = $product->{ConfigOptions::PRODUCT_ENABLE_SAN} === 'on';
        $isSanEnabledWildcard = $product->{ConfigOptions::PRODUCT_ENABLE_SAN_WILDCARD} === 'on';
        $configOptions = new ConfigOptionsRepo($service->id);

        $server = new Server();
        if (!$server->loadByServiceID($service->id)) {
            Whmcs::savelogActivityRealtimeRegisterSsl(
                "Realtime Register SSL WHMCS: Required Product Module '" . $server->getServiceModule() . "' Missing"
            );
        }
        $serviceParams = $server->buildParams();
        if ($isSanEnabled) {
            $configoptionsResults['single'] = [
                'configOptionID' => $configOptions->getOptionID(ConfigOptions::OPTION_SANS_COUNT),
                'configID' => $configOptions->getConfigID(ConfigOptions::OPTION_SANS_COUNT),
                'boughtSans' => $serviceParams['configoptions'][ConfigOptions::OPTION_SANS_COUNT],
                'friendlyName' => $configOptions->getFriendlyName(ConfigOptions::OPTION_SANS_COUNT),
                'billingCycle' => $service->billingcycle === 'One Time'
                    ? 'monthly'
                    : $service->billingcycle
            ];
        }


        if ($isSanEnabledWildcard) {
            $configoptionsResults['wildcard'] = [
                'configOptionID' => $configOptions->getOptionID(ConfigOptions::OPTION_SANS_WILDCARD_COUNT),
                'configID' => $configOptions->getConfigID(ConfigOptions::OPTION_SANS_WILDCARD_COUNT),
                'boughtSans' => $serviceParams['configoptions'][ConfigOptions::OPTION_SANS_WILDCARD_COUNT],
                'friendlyName' => $configOptions->getFriendlyName(ConfigOptions::OPTION_SANS_WILDCARD_COUNT),
                'billingCycle' => $service->billingcycle === 'One Time'
                    ? 'monthly'
                    : $service->billingcycle
            ];
        }

        return $configoptionsResults;
    }

    public function moduleCreate($serviceId)
    {
        $command = 'ModuleCreate';
        $postData = [
            'accountid' => $serviceId,
        ];
        $adminUsername = Admin::getAdminUserName();

        $results = localAPI($command, $postData, $adminUsername);

        return $results['result'] == 'success';
    }

    public static function markPreviousOrderAsCompleted($serviceID)
    {
        $invoiceInfo = self::getNewInvoiceCreatedInfo($serviceID);

        if ($invoiceInfo == null) {
            return false;
        }

        $service = \WHMCS\Service\Service::find($invoiceInfo['service_id']);
        $service->status = 'Completed';
        $service->save();

        Query::update(self::INVOICE_INFOS_TABLE_NAME, ['status' => 'configured'], ['id' => $invoiceInfo['id']]);

        return true;
    }

    protected function saveInvoiceInfo($userId, $invoiceId, $serviceId, $productId)
    {
        Query::insert(self::INVOICE_INFOS_TABLE_NAME, [
            'user_id' => $userId,
            'invoice_id' => $invoiceId,
            'service_id' => $serviceId,
            'product_id' => $productId,
            'created_at' => date('Y-m-d H:i:s')
        ]);
    }

    public static function insertDomainInfoIntoInvoiceItemDescription($serviceID, $domain, $checkIfAlreadyIncluded = false)
    {
        try {
            $service = new Service($serviceID);
            $whmcsProduct = $service->product();

            if ($whmcsProduct->getShowDomainOptions() || $whmcsProduct->getPayType() == 'free') {
                return;
            }

            //get invoice related with order
            $whmcsOrder = $service->order();
            $invoice = $whmcsOrder->invoice();
            $invoiceItemsRepo = new RepositoryItem();
            $invoiceItemsRepo->onlyInvoiceId($invoice->getId())->onlyServiceId($serviceID);
            $serviceInvoiceItems = $invoiceItemsRepo->get();
            foreach ($serviceInvoiceItems as $item) {
                $domainInfo = $whmcsProduct->getName() . ' - ' . $domain;
                if ($checkIfAlreadyIncluded && $domainIncluded = self::checkIfAddedDomainInfoInInvoiceItemDescription(
                        $item->getDescription(),
                        $whmcsProduct->getName()
                    )) {
                    $newDescription = str_replace($whmcsProduct->getName() . ' ' . $domainIncluded, $domainInfo, $item->getDescription());
                } else {
                    $newDescription = str_replace($whmcsProduct->getName(), $domainInfo, $item->getDescription());
                }

                $oldDescription = $item->getDescription();
                $item->setDescription($newDescription);
                $item->save();

                Whmcs::savelogActivityRealtimeRegisterSsl(
                    "Realtime Register SSL WHMCS: Description of the invoice item for Invoice ID: "
                    . $invoice->getId() . ' has been changed from "' . $oldDescription . '" to "' . $newDescription . '"'
                );
            }
        } catch (\Exception $e) {
            return;
        }
    }

    private static function checkIfAddedDomainInfoInInvoiceItemDescription($itemDescription, $productName)
    {
        $itemDescription = str_replace($productName, '', $itemDescription);

        $start = strpos($itemDescription, ' - ');
        if ($start === false) {
            return false;
        }


        $end = strpos($itemDescription, '(', $start + 1);
        if ($end === false) {
            $end = strpos($itemDescription, ' Setup Fee', $start + 1);
        }
        if ($end === false) {
            $end = strpos($itemDescription, PHP_EOL, $start + 1);
        }
        if ($end === false) {
            return ltrim($itemDescription, ' - ');
        }

        $length = $end - $start;
        if ($length == null) {
            return false;
        }

        $domain = substr($itemDescription, $start + 1, $length - 1);
        if (trim($domain) == '') {
            return false;
        }

        return $domain;
    }
}
