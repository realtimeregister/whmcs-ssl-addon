<?php

namespace AddonModule\RealtimeRegisterSsl\eServices;

use AddonModule\RealtimeRegisterSsl\eHelpers\Whmcs;
use AddonModule\RealtimeRegisterSsl\eRepository\RealtimeRegisterSsl\KeyToIdMapping;
use AddonModule\RealtimeRegisterSsl\eRepository\RealtimeRegisterSsl\ProductsPrices;
use AddonModule\RealtimeRegisterSsl\eServices\provisioning\ConfigOptions;
use AddonModule\RealtimeRegisterSsl\models\productConfiguration\Repository as ProductRepository;
use AddonModule\RealtimeRegisterSsl\models\productPrice\Repository as ApiProductPriceRepo;
use Illuminate\Database\Capsule\Manager as Capsule;

class ConfigurableOptionService
{
    public static function getForProduct($productId, $name = 'sans_count')
    {
        return Capsule::table('tblproductconfiggroups')
            ->select(['tblproductconfigoptions.id', 'tblproductconfiggroups.id as groupid'])
            ->join('tblproductconfigoptions', 'tblproductconfigoptions.gid', '=', 'tblproductconfiggroups.id')
            ->where(
                'tblproductconfiggroups.description',
                '=',
                'Auto generated by module - RealtimeRegisterSSL #' . $productId
            )
            ->where('tblproductconfigoptions.optionname', 'LIKE', $name . '%')
            ->get();
    }

    public static function getForProductWildcard($productId)
    {
        return self::getForProduct($productId, 'sans_wildcard_count');
    }

    public static function createForProduct($productId, $apiProductId, $name, $apiProduct, $payType)
    {
        if (!self::getForProduct($productId)->isEmpty()) {
            return null;
        }

        $optionGroupId = self::getOptionGroup($name, $productId);

        self::insertOptions($apiProductId, $apiProduct, $payType, [
            "optionGroupId" => $optionGroupId,
            "optionName" => provisioning\ConfigOptions::OPTION_SANS_COUNT . "|Additional Single domain SANs",
            "action" => "EXTRA_DOMAIN",
            "maximum" => $apiProduct->getMaxDomains() - $apiProduct->getIncludedDomains(),
        ]);
    }

    public static function createForProductWildCard($productId, $apiProductId, $name, $apiProduct, $payType)
    {
        if (!self::getForProductWildcard($productId)->isEmpty()) {
            return;
        }

        $optionGroupId = self::getOptionGroup($name, $productId);

        self::insertOptions($apiProductId, $apiProduct, $payType, [
            "optionGroupId" => $optionGroupId,
            "optionName" => provisioning\ConfigOptions::OPTION_SANS_WILDCARD_COUNT . "|Additional Wildcard domain SANs",
            "action" => "EXTRA_WILDCARD",
            "maximum" => $apiProduct->getMaxDomains() - $apiProduct->getIncludedDomains()
        ]);
    }

    public static function createHiddenField($productId) {
        Capsule::table('tblcustomfields')->insert(
            [
                'type' => 'product',
                'fieldtype' => 'hidden',
                'relid' => $productId,
                'showorder' => 'on'
            ]
        );
    }

    private static function getOptionGroup($name, $productId) : int {
        $optionGroupResult = Capsule::table('tblproductconfiggroups')
            ->select('id')
            ->where('name', '=', 'RealtimeRegisterSsl - ' . $name)
            ->where('description', '=', 'Auto generated by module - RealtimeRegisterSSL #' . $productId)
            ->first();

        if ($optionGroupResult != null) {
            return $optionGroupResult->id;
        }
        $optionGroup = [
            'name' => 'RealtimeRegisterSsl - ' . $name,
            'description' => 'Auto generated by module - RealtimeRegisterSSL #' . $productId
        ];
        $optionGroupId = Capsule::table('tblproductconfiggroups')->insertGetId($optionGroup);

        $optionLink = [
            'gid' => $optionGroupId,
            'pid' => $productId
        ];
        Capsule::table('tblproductconfiglinks')->insert($optionLink);
        return $optionGroupId;
    }

    public static function generateNewPricesBasedOnCommission($commission, $product)
    {
        $pricings = Capsule::table('tblpricing')
            ->where('relid', '=', $product->id)
            ->get()
            ->toArray();

        foreach ($pricings as $pricing) {
            Capsule::table('tblpricing')
                ->where('id', '=', $pricing->id)
                ->update([
                    "msetupfee" => self::updatePrice($pricing->msetupfee, $product, $commission),
                    "asetupfee" => self::updatePrice($pricing->asetupfee, $product, $commission),
                    "bsetupfee" => self::updatePrice($pricing->bsetupfee, $product, $commission),
                    "tsetupfee" => self::updatePrice($pricing->tsetupfee, $product, $commission),
                    "monthly" => self::updatePrice($pricing->monthly, $product, $commission),
                    "annually" => self::updatePrice($pricing->annually, $product, $commission),
                    "biennially" => self::updatePrice($pricing->biennially, $product, $commission),
                    "triennially" => self::updatePrice($pricing->triennially, $product, $commission),
                ]);
        }


        $optionGroupResult = Capsule::table('tblproductconfiggroups')
            ->select('id')
            ->where('description', '=', 'Auto generated by module - RealtimeRegisterSSL #' . $product->id)
            ->first();

        if ($optionGroupResult == null) {
            return;
        }

        $configOptions = Capsule::table('tblproductconfigoptions')
            ->select()
            ->where('gid', '=', $optionGroupResult->id)
            ->get();

        foreach($configOptions as $configOption) {
            $configOptionSubs = Capsule::table('tblproductconfigoptionssub')
                ->select()
                ->where('configid', '=', $configOption->id)
                ->orderBy('sortorder')
                ->get();

            foreach ($configOptionSubs as $configOptionSub) {
                $pricings = Capsule::table('tblpricing')
                    ->where('relid', '=', $configOptionSub->id)
                    ->get()
                    ->toArray();

                foreach ($pricings as $pricing) {
                    Capsule::table('tblpricing')
                        ->where('id', '=', $pricing->id)
                        ->update([
                            "msetupfee" => self::updatePrice($pricing->msetupfee, $product, $commission),
                            "asetupfee" => self::updatePrice($pricing->asetupfee, $product, $commission),
                            "bsetupfee" => self::updatePrice($pricing->bsetupfee, $product, $commission),
                            "tsetupfee" => self::updatePrice($pricing->tsetupfee, $product, $commission),
                            "monthly" => self::updatePrice($pricing->monthly, $product, $commission),
                            "annually" => self::updatePrice($pricing->annually, $product, $commission),
                            "biennially" => self::updatePrice($pricing->biennially, $product, $commission),
                            "triennially" => self::updatePrice($pricing->triennially, $product, $commission),
                        ]);
                }
            }
        }
    }

    private static function updatePrice($price, $product, $commission) {
        $oldCommission = $product->{ConfigOptions::COMMISSION} === '' ? 0 : $product->{ConfigOptions::COMMISSION};
        return $price == -1.00 ? $price : $price / (1 + $oldCommission) * (1 + $commission);
    }

    private static function insertOptions(mixed $apiProductId, mixed $apiProduct, string $payType, array $options) {
        $periods = $apiProduct->getPeriods();
        $productModel = new ProductRepository();

        sort($periods);

        $priceRepo = new ApiProductPriceRepo();

        // The prices are sometimes not imported yet, so we force an import when there is no data
        self::loadPrices($priceRepo, $apiProductId);

        $currencies = $productModel->getAllCurrencies();
        $defaultCurrency = $currencies->filter(fn($currency) => $currency->default === 1)->first();

        $option = [
            'gid' => $options['optionGroupId'],
            'optionname' => $options['optionName'],
            'optiontype' => 4,
            'qtyminimum' => 0,
            'qtymaximum' => $options['maximum'],
            'order' => 1,
            'hidden' => 0,
        ];
        $optionId = Capsule::table('tblproductconfigoptions')->insertGetId($option);

        $optionsSub = [
            'configid' => $optionId,
            'optionname' => 'SAN',
            'sortorder' => 0,
            'hidden' => 0,
        ];
        $optionSubId = Capsule::table('tblproductconfigoptionssub')->insertGetId($optionsSub);

        $pricing = [
            'type' => 'configoptions',
            'currency' => 'xxxx',
            'relid' => $optionSubId,
            'msetupfee' => '0.00',
            'qsetupfee' => '0.00',
            'ssetupfee' => '0.00',
            'asetupfee' => '0.00',
            'bsetupfee' => '0.00',
            'tsetupfee' => '0.00',
            'monthly' => -1.00,
            'quarterly' => '0.00',
            'semiannually' => '0.00',
            'annually' => -1.00,
            'biennially' => -1.00,
            'triennially' => -1.00,
        ];

        foreach($periods as $period) {
            $price = $priceRepo->onlyApiProductID(KeyToIdMapping::getIdByKey($apiProductId))
                    ->onlyPeriod($period)
                    ->onlyAction($options['action'])
                    ->fetchOne();
            $basePrice = self::getBasePrice($currencies, $price, $defaultCurrency);

            switch ($period) {
                case 12:
                    if ($payType === 'onetime') {
                        $pricing['monthly'] = $basePrice;
                    }
                    $pricing['annually'] = $basePrice;
                    break;
                case 24:
                    $pricing['biennially'] = $basePrice;
                    break;
                case 36:
                    $pricing['triennially'] = $basePrice;
                    break;
                default:
                    break;
            }
        }

        foreach ($currencies as $currency) {
            $pricing['currency'] = $currency->id;
            $pricing['monthly'] = $pricing['monthly'] === -1.00
                ? $pricing['monthly']
                : $pricing['monthly'] * $currency->rate;
            $pricing['annually'] = $pricing['annually'] === -1.00
                ? $pricing['annually']
                : $pricing['annually'] * $currency->rate;
            $pricing['biennially'] = $pricing['biennially'] === -1.00
                ? $pricing['biennially']
                : $pricing['biennially'] * $currency->rate;
            $pricing['triennially'] = $pricing['triennially'] === -1.00
                ? $pricing['triennially']
                : $pricing['triennially'] * $currency->rate;
            Capsule::table('tblpricing')->insert($pricing);
        }
    }

    /**
     * @param ApiProductPriceRepo $priceRepo
     * @param $apiProductId
     * @return void
     */
    public static function loadPrices(ApiProductPriceRepo $priceRepo, $apiProductId): void
    {
        try {
            $priceRepo->onlyApiProductID(KeyToIdMapping::getIdByKey($apiProductId))->fetchOne();
        } catch (\Exception $e) {
            Whmcs::savelogActivityRealtimeRegisterSsl("Realtime Register SSL WHMCS: loaded prices because they weren't available.");

            $apiProductsPrices = ProductsPrices::getInstance();
            foreach ($apiProductsPrices->getAllProductsPrices() as $productPrice) {
                $productPrice->saveToDatabase();
            }
        }
    }

    public static function getConfigOptionById($optionId) {
        return Capsule::table("tblproductconfigoptions")
            ->where("id", "=", $optionId)
            ->first();
    }

    public static function getConfigOptionSubByOptionId($optionId) {
        return Capsule::table("tblproductconfigoptionssub")
            ->where("configid", "=", $optionId)
            ->first();
    }

    public static function getBasePrice($currencies, $apiPrice, $defaultCurrency) {
        if ($apiPrice->currency !== $defaultCurrency->code) {
            $currency = $currencies->filter(function($currency) use ($apiPrice) {
                return $apiPrice->currency === $currency->code;
            })->first();
            if ($currency === null) {
                return -1.00;
            }
            return $apiPrice->price / $currency->rate / 100;
        } else {
            return $apiPrice->price / 100;
        }
    }
}
